#Porphyrin tools - the set of functions which allow for generation of the Normal-coordinate Structural Decomposition matrix and 
#associated bond distances, angles, etc, an indispensible tool for the structural analysis of porphyrin materials.
#written by Dr. Christopher J. Kingsbury, Trinity College Dublin 
#ckingsbu@tcd.ie

#This work is licensed under the Creative Commons Attribution-NonCommercial 4.0 International License. 
#To view a copy of this license, visit http://creativecommons.org/licenses/by-nc/4.0/ or send a letter to 
#Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.

#imports - matplotlib for plotting the skeletal images
#numpy for general number handling
#os is reads fines from 
import matplotlib.pyplot as plt 
import numpy as np
from numpy.linalg import norm
from os import getcwd
import pandas as pd
from scipy.optimize import minimize, leastsq, linear_sum_assignment
from scipy.spatial.transform import Rotation as R

from matplotlib.patches import ArrowStyle

#This is the replica of NSDGUI - or at least the matrix stuff behind it. basis sets were obtained from Jentzen's paper
# as were the multiplicative matrices. 
# linalg.lstsq runs on only the first column of each matrix - this is the minimum basis set
# can be modified to run on the extended data set
# This is V2, which works in a much more sensible way. Values are essentially immutable, 
# but can be regenerated by other code, available on request
#the x,y,z coordinates for generation of databases were obtained from Mercury (CCDC) and the
# CSDmaterials - similarity search algorithm (chemical) and from the export function of the Protein Data Bank (PDB)
#Plan to replicate in CSD Python API.

nb_b2u = np.matrix([[0.13997, 0.320469, 0.320469, 0.13997, 0.0, -0.13997, -0.320469, -0.320469, -0.13997, 0.0, 0.13997, 0.320469, 0.320469, 0.13997, 0.0, -0.13997, -0.320469, -0.320469, -0.13997, 0.0, 0.073594,  -0.073594, 0.073594, -0.073594], 
	[0.176231, -0.12957, -0.12957, 0.176231, 0.0, -0.176231, 0.12957, 0.12957, -0.176231, 0.0,  0.176231, -0.12957, -0.12957, 0.176231, 0.0, -0.176231, 0.12957, 0.12957, -0.176231, 0.0,  0.392821, -0.392821, 0.392821, -0.392821], 
	[-0.284657, 0.088308, 0.088308, -0.284657, 0.0, 0.284657, -0.088308, -0.088308, 0.284657, 0.0, -0.284657, 0.088308, 0.088308, -0.284657, 0.0, 0.284657, -0.088308, -0.088308, 0.284657, 0.0,  0.268968, -0.268968, 0.268968, -0.268968]]).transpose()
nb_b1u = np.matrix([[-0.208239, -0.138509, 0.138509, 0.208239, 0.353418, 0.208239, 0.138509, -0.138509, -0.208239, -0.353418, -0.208239, -0.138509, 0.138509, 0.208239, 0.353418, 0.208239, 0.138509, -0.138509, -0.208239, -0.353418, 0.0, 0.0, 0.0, 0.0], 
	[0.05526, 0.283868, -0.283868, -0.05526, 0.287628, -0.05526, -0.283868, 0.283868, 0.05526, -0.287628, 0.05526, 0.283868, -0.283868, -0.05526, 0.287628, -0.05526, -0.283868, 0.283868, 0.05526, -0.287628, 0.0, 0.0, 0.0, 0.0], 
	[0.280329, -0.158849, 0.158849, -0.280329, 0.205829, -0.280329, 0.158849, -0.158849, 0.280329, -0.205829, 0.280329, -0.158849, 0.158849, -0.280329, 0.205829, -0.280329, 0.158849, -0.158849, 0.280329, -0.205829, 0.0, 0.0, 0.0, 0.0]]).transpose()
nb_a2u = np.matrix([[0.089421, -0.256764, -0.256764, 0.089421, 0.015446, 0.089421, -0.256764, -0.256764, 0.089421, 0.015446, 0.089421, -0.256764, -0.256764, 0.089421, 0.015446, 0.089421, -0.256764, -0.256764, 0.089421, 0.015446, 0.31924, 0.31924, 0.31924, 0.31924],
	[-0.026474, 0.129163, 0.129163, -0.026474, -0.414251, -0.026474, 0.129163, 0.129163, -0.026474, -0.414251, -0.026474, 0.129163, 0.129163, -0.026474, -0.414251, -0.026474, 0.129163, 0.129163, -0.026474, -0.414251, 0.208873, 0.208873, 0.208873, 0.208873],
	[-0.276428, 0.066317, 0.066317, -0.276428, 0.203582, -0.276428, 0.066317, 0.066317, -0.276428, 0.203582, -0.276428, 0.066317, 0.066317, -0.276428, 0.203582, -0.276428, 0.066317, 0.066317, -0.276428, 0.203582, 0.216642, 0.216642, 0.216642, 0.216642]]).transpose()
nb_egx = np.matrix([[0.091793, -0.321091, -0.321091, 0.091793, 0.222472, 0.200466, 0.142778, -0.142778, -0.200466, -0.222472, -0.091793, 0.321091, 0.321091, -0.091793, -0.222472, -0.200466, -0.142778, 0.142778, 0.200466, 0.222472, 0.238363, 0.0, -0.238363, 0.0], 
	[0.188697, -0.059908, -0.059908, 0.188697, -0.17926, -0.194656, -0.166003, 0.166003, 0.194656, 0.17926, -0.188697, 0.059908, 0.059908, -0.188697, 0.17926, 0.194656, 0.166003, -0.166003, -0.194656, -0.17926, 0.475862, -0.0, -0.475862, -0.0], 
	[-0.0646, 0.085263, 0.085263, -0.0646, -0.303576, 0.149899, 0.330986, -0.330986, -0.149899, 0.303576, 0.0646, -0.085263, -0.085263, 0.0646, 0.303576, -0.149899, -0.330986, 0.330986, 0.149899, -0.303576, 0.169573, -0.0, -0.169573, -0.0], 
	[-0.153961, 0.061081, 0.061081, -0.153961, -0.058147, 0.345711, -0.298751, 0.298751, -0.345711, 0.058147, 0.153961, -0.061081, -0.061081, 0.153961, 0.058147, -0.345711, 0.298751, -0.298751, 0.345711, -0.058147, 0.144332, -0.0, -0.144332, -0.0], 
	[-0.357004, 0.089594, 0.089594, -0.357004, 0.190206, -0.163121, 0.063411, -0.063411, 0.163121, -0.190206, 0.357004, -0.089594, -0.089594, 0.357004, -0.190206, 0.163121, -0.063411, 0.063411, -0.163121, 0.190206, 0.308912, -0.0, -0.308912, -0.0]]).transpose()
nb_egy = np.matrix([[-0.200466, -0.142778, 0.142778, 0.200466, 0.222472, 0.091793, -0.321091, -0.321091, 0.091793, 0.222472, 0.200466, 0.142778, -0.142778, -0.200466, -0.222472, -0.091793, 0.321091, 0.321091, -0.091793, -0.222472, 0.0, 0.238363, 0.0, -0.238363],
 	[0.194656, 0.166003, -0.166003, -0.194656, -0.17926, 0.188697, -0.059908, -0.059908, 0.188697, -0.17926, -0.194656, -0.166003, 0.166003, 0.194656, 0.17926, -0.188697, 0.059908, 0.059908, -0.188697, 0.17926, -0.0, 0.475862, -0.0, -0.475862], 
 	[-0.149899, -0.330986, 0.330986, 0.149899, -0.303576, -0.0646, 0.085263, 0.085263, -0.0646, -0.303576, 0.149899, 0.330986, -0.330986, -0.149899, 0.303576, 0.0646, -0.085263, -0.085263, 0.0646, 0.303576, -0.0, 0.169573, -0.0, -0.169573],
  	[-0.345711, 0.298751, -0.298751, 0.345711, -0.058147, -0.153961, 0.061081, 0.061081, -0.153961, -0.058147, 0.345711, -0.298751, 0.298751, -0.345711, 0.058147, 0.153961, -0.061081, -0.061081, 0.153961, 0.058147, -0.0, 0.144332, -0.0, -0.144332], 
  	[0.163121, -0.063411, 0.063411, -0.163121, 0.190206, -0.357004, 0.089594, 0.089594, -0.357004, 0.190206, -0.163121, 0.063411, -0.063411, 0.163121, -0.190206, 0.357004, -0.089594, -0.089594, 0.357004, -0.190206, -0.0, 0.308912, -0.0, -0.308912]]).transpose()
nb_a1u = np.matrix([[0.244613, 0.255273, -0.255273, -0.244613, 0.0, 0.244613, 0.255273, -0.255273, -0.244613, 0.0, 0.244613, 0.255273, -0.255273, -0.244613, 0.0, 0.244613, 0.255273, -0.255273, -0.244613, 0.0, 0.0, 0.0, 0.0, 0.0], 
	[0.255273, -0.244613, 0.244613, -0.255273, 0.0, 0.255273, -0.244613, 0.244613, -0.255273, 0.0, 0.255273, -0.244613, 0.244613, -0.255273, 0.0, 0.255273, -0.244613, 0.244613, -0.255273, 0.0, 0.0, 0.0, 0.0, 0.0]]).transpose()
oopbases = [nb_b2u, nb_b1u, nb_a2u, nb_egx, nb_egy, nb_a1u]
oop_comp_base_num = [[0,3],[3,6],[6,9],[9,14],[14,19],[19,21]]

# These are the functions which generate the NSD matrices from numpy.linalg.lstsq on the selected matrix elements, 
# the subsets of the total NSD normal coordinate vectors described above. These are either the first element (min), 
# elements 1 and 2 of each (Ext.) or the total matrix set (total) - Comp is the sum of squares of the total elements.
# both in plane and out-of-plane (ip and oop) work in the same fashion, though the 24*2 matrix of the in plane elements
# were refashioned as 48-arrays to avoid multidimensional matrix confusion. I'm sure the answers are mathematically identical.

def gen_linalg_oop_min(zdata):
	bigmat = np.hstack(([x[:,0] for x in oopbases]))
	linalgdata = np.linalg.lstsq(bigmat, np.array(zdata).reshape(24),rcond = None)
	linalg_doop = np.sqrt(np.sum(np.square(linalgdata[0])))
	linalgout = np.hstack((linalgdata[0],linalg_doop,linalgdata[1]/4)).flatten()
	return linalgout

def gen_linalg_oop_ext(zdata):
	bigmat = np.hstack(([x[:,0:2] for x in oopbases]))
	linalgdata = np.linalg.lstsq(bigmat, np.array(zdata).reshape(24),rcond = None)
	linalg_doop = np.sqrt(np.sum(np.square(linalgdata[0])))
	linalgout = np.hstack((linalgdata[0],linalg_doop,linalgdata[1]/4)).flatten()
	return linalgout

def gen_linalg_oop_comp(zdata):
	bigmat = np.hstack((oopbases))
	linalgdata = np.linalg.lstsq(bigmat, np.array(zdata).reshape(24),rcond = None)
	linalgsum = []
	for i in oop_comp_base_num:
		linalgsum.append(np.sqrt(np.sum(np.square(linalgdata[0][i[0]:i[1]]))))
	linalg_doop = np.sqrt(np.sum(np.square(linalgdata[0])))
	linalgout = np.hstack((linalgsum,linalg_doop,linalgdata[1]/4)).flatten()
	return linalgout

def gen_linalg_oop_total(zdata):
	bigmat = np.hstack((oopbases))
	linalgdata = np.linalg.lstsq(bigmat, np.array(zdata).reshape(24),rcond = None)
	linalg_doop = np.sqrt(np.sum(np.square(linalgdata[0])))
	linalgout = np.hstack((linalgdata[0],linalg_doop,linalgdata[1]/4)).flatten()
	return linalgout
	
nb_b2g = [[0.180958, -0.114829, 0.062829, -0.073186, 0.062829, 0.073186, 0.180958, 0.114829, 0.201078, 0.201078, 0.114829, 0.180958, 0.073186, 0.062829, -0.073186, 0.062829, -0.114829, 0.180958, -0.201078, 0.201078, -0.180958, 0.114829, -0.062829, 0.073186, -0.062829, -0.073186, -0.180958, -0.114829, -0.201078, -0.201078, -0.114829, -0.180958, -0.073186, -0.062829, 0.073186, -0.062829, 0.114829, -0.180958, 0.201078, -0.201078, 0.242208, -0.0, -0.0, 0.242208, -0.242208, -0.0, -0.0, -0.242208], 
	[-0.035761, -0.091143, -0.328661, -0.076605, -0.328661, 0.076605, -0.035761, 0.091143, 0.025615, 0.025615, 0.091143, -0.035761, 0.076605, -0.328661, -0.076605, -0.328661, -0.091143, -0.035761, -0.025615, 0.025615, 0.035761, 0.091143, 0.328661, 0.076605, 0.328661, -0.076605, 0.035761, -0.091143, -0.025615, -0.025615, -0.091143, 0.035761, -0.076605, 0.328661, 0.076605, 0.328661, 0.091143, 0.035761, 0.025615, -0.025615, 0.041751, -0.0, -0.0, 0.041751, -0.041751, -0.0, -0.0, -0.041751], 
	[0.055255, 0.167267, -0.096708, 0.247136, -0.096708, -0.247136, 0.055255, -0.167267, 0.152858, 0.152858, -0.167267, 0.055255, -0.247136, -0.096708, 0.247136, -0.096708, 0.167267, 0.055255, -0.152858, 0.152858, -0.055255, -0.167267, 0.096708, -0.247136, 0.096708, 0.247136, -0.055255, 0.167267, -0.152858, -0.152858, 0.167267, -0.055255, 0.247136, 0.096708, -0.247136, 0.096708, -0.167267, -0.055255, 0.152858, -0.152858, 0.018671, -0.0, -0.0, 0.018671, -0.018671, -0.0, -0.0, -0.018671], 
	[0.037155, 0.028774, -0.02385, 0.087645, -0.02385, -0.087645, 0.037155, -0.028774, -0.226991, -0.226991, -0.028774, 0.037155, -0.087645, -0.02385, 0.087645, -0.02385, 0.028774, 0.037155, 0.226991, -0.226991, -0.037155, -0.028774, 0.02385, -0.087645, 0.02385, 0.087645, -0.037155, 0.028774, 0.226991, 0.226991, 0.028774, -0.037155, 0.087645, 0.02385, -0.087645, 0.02385, -0.028774, -0.037155, -0.226991, 0.226991, 0.355011, -0.0, -0.0, 0.355011, -0.355011, -0.0, -0.0, -0.355011], 
	[-0.12849, -0.25599, 0.04045, 0.20159, 0.04045, -0.20159, -0.12849, 0.25599, 0.0258, 0.0258, 0.25599, -0.12849, -0.20159, 0.04045, 0.20159, 0.04045, -0.25599, -0.12849, -0.0258, 0.0258, 0.12849, 0.25599, -0.04045, -0.20159, -0.04045, 0.20159, 0.12849, -0.25599, -0.0258, -0.0258, -0.25599, 0.12849, 0.20159, -0.04045, -0.20159, -0.04045, 0.25599, 0.12849, 0.0258, -0.0258, 0.006241, -0.0, -0.0, 0.006241, -0.006241, -0.0, -0.0, -0.006241], 
	[-0.27073, 0.10004, 0.042958, -0.073036, 0.042958, 0.073036, -0.27073, -0.10004, 0.11931, 0.11931, -0.10004, -0.27073, 0.073036, 0.042958, -0.073036, 0.042958, 0.10004, -0.27073, -0.11931, 0.11931, 0.27073, -0.10004, -0.042958, 0.073036, -0.042958, -0.073036, 0.27073, 0.10004, -0.11931, -0.11931, 0.10004, 0.27073, -0.073036, -0.042958, 0.073036, -0.042958, -0.10004, 0.27073, 0.11931, -0.11931, 0.20141, -0.0, -0.0, 0.20141, -0.20141, -0.0, -0.0, -0.20141]]
nb_b1g = [[-0.023567, -0.208329, 0.001194, -0.237409, -0.001194, -0.237409, 0.023567, -0.208329, 0.077676, -0.077676, 0.208329, -0.023567, 0.237409, 0.001194, 0.237409, -0.001194, 0.208329, 0.023567, 0.077676, 0.077676, 0.023567, 0.208329, -0.001194, 0.237409, 0.001194, 0.237409, -0.023567, 0.208329, -0.077676, 0.077676, -0.208329, 0.023567, -0.237409, -0.001194, -0.237409, 0.001194, -0.208329, -0.023567, -0.077676, -0.077676, 0.0, -0.193109, 0.193109, 0.0, 0.0, 0.193109, -0.193109, 0.0], 
	[0.224002, -0.019963, 0.057892, -0.014825, -0.057892, -0.014825, -0.224002, -0.019963, -0.245022, 0.245022, 0.019963, 0.224002, 0.014825, 0.057892, 0.014825, -0.057892, 0.019963, -0.224002, -0.245022, -0.245022, -0.224002, 0.019963, -0.057892, 0.014825, 0.057892, 0.014825, 0.224002, 0.019963, 0.245022, -0.245022, -0.019963, -0.224002, -0.014825, -0.057892, -0.014825, 0.057892, -0.019963, 0.224002, 0.245022, 0.245022, 0.0, -0.147091, 0.147091, 0.0, 0.0, 0.147091, -0.147091, 0.0], 
	[-0.017364, -0.078018, -0.023778, 0.247151, 0.023778, 0.247151, 0.017364, -0.078018, 0.081045, -0.081045, 0.078018, -0.017364, -0.247151, -0.023778, -0.247151, 0.023778, 0.078018, 0.017364, 0.081045, 0.081045, 0.017364, 0.078018, 0.023778, -0.247151, -0.023778, -0.247151, -0.017364, 0.078018, -0.081045, 0.081045, -0.078018, 0.017364, 0.247151, 0.023778, 0.247151, -0.023778, -0.078018, -0.017364, -0.081045, -0.081045, -0.0, -0.317472, 0.317472, -0.0, -0.0, 0.317472, -0.317472, -0.0], 
	[-0.09148, 0.21262, 0.21367, -0.074807, -0.21367, -0.074807, 0.09148, 0.21262, 0.023399, -0.023399, -0.21262, -0.09148, 0.074807, 0.21367, 0.074807, -0.21367, -0.21262, 0.09148, 0.023399, 0.023399, 0.09148, -0.21262, -0.21367, 0.074807, 0.21367, 0.074807, -0.09148, -0.21262, -0.023399, 0.023399, 0.21262, 0.09148, -0.074807, -0.21367, -0.074807, 0.21367, 0.21262, -0.09148, -0.023399, -0.023399, -0.0, -0.19812, 0.19812, -0.0, -0.0, 0.19812, -0.19812, -0.0], 
	[-0.124551, 0.115461, -0.254912, -0.063452, 0.254912, -0.063452, 0.124551, 0.115461, -0.128791, 0.128791, -0.115461, -0.124551, 0.063452, -0.254912, 0.063452, 0.254912, -0.115461, 0.124551, -0.128791, -0.128791, 0.124551, -0.115461, 0.254912, 0.063452, -0.254912, 0.063452, -0.124551, -0.115461, 0.128791, -0.128791, 0.115461, 0.124551, -0.063452, 0.254912, -0.063452, -0.254912, 0.115461, -0.124551, 0.128791, 0.128791, 0.0, -0.145341, 0.145341, 0.0, 0.0, 0.145341, -0.145341, 0.0], 
	[0.226637, 0.139228, -0.112329, -0.055827, 0.112329, -0.055827, -0.226637, 0.139228, 0.192238, -0.192238, -0.139228, 0.226637, 0.055827, -0.112329, 0.055827, 0.112329, -0.139228, -0.226637, 0.192238, 0.192238, -0.226637, -0.139228, 0.112329, 0.055827, -0.112329, 0.055827, 0.226637, -0.139228, -0.192238, 0.192238, 0.139228, -0.226637, -0.055827, 0.112329, -0.055827, -0.112329, 0.139228, 0.226637, -0.192238, -0.192238, -0.0, -0.055878, 0.055878, -0.0, -0.0, 0.055878, -0.055878, -0.0]]
nb_eux = [[0.10224, 0.077914, 0.344167, 0.060891, 0.344167, -0.060891, 0.10224, -0.077914, 0.035076, -0.081925, -0.172156, -0.068549, -0.206736, -0.019998, -0.206736, 0.019998, -0.172156, 0.068549, 0.035076, 0.081925, 0.10224, 0.077914, 0.344167, 0.060891, 0.344167, -0.060891, 0.10224, -0.077914, 0.035076, -0.081925, -0.172156, -0.068549, -0.206736, -0.019998, -0.206736, 0.019998, -0.172156, 0.068549, 0.035076, 0.081925, 0.021404, -0.0, -0.226586, 0.0, 0.021404, -0.0, -0.226586, 0.0], 
	[0.155696, -0.216515, -0.128747, -0.159216, -0.128747, 0.159216, 0.155696, 0.216515, 0.135877, 0.170816, -0.100897, 0.060248, -0.154426, -0.001075, -0.154426, 0.001075, -0.100897, -0.060248, 0.135877, -0.170816, 0.155696, -0.216515, -0.128747, -0.159216, -0.128747, 0.159216, 0.155696, 0.216515, 0.135877, 0.170816, -0.100897, 0.060248, -0.154426, -0.001075, -0.154426, 0.001075, -0.100897, -0.060248, 0.135877, -0.170816, 0.300102, -0.0, -0.115107, 0.0, 0.300102, -0.0, -0.115107, 0.0], 
	[0.103108, 0.0506, -0.214721, 0.022606, -0.214721, -0.022606, 0.103108, -0.0506, 0.065171, -0.317741, -0.014581, -0.243211, 0.046099, -0.049714, 0.046099, 0.049714, -0.014581, 0.243211, 0.065171, 0.317741, 0.103108, 0.0506, -0.214721, 0.022606, -0.214721, -0.022606, 0.103108, -0.0506, 0.065171, -0.317741, -0.014581, -0.243211, 0.046099, -0.049714, 0.046099, 0.049714, -0.014581, 0.243211, 0.065171, 0.317741, 0.159148, -0.0, -0.12931, -0.0, 0.159148, -0.0, -0.12931, -0.0], 
	[-0.05213, -0.231435, 0.154068, -0.286694, 0.154068, 0.286694, -0.05211, 0.231435, -0.220664, -0.132272, -0.014687, -0.080668, 0.119329, 0.001925, 0.119329, -0.001925, -0.014687, 0.080668, -0.220664, 0.132272, -0.05213, -0.231435, 0.154068, -0.286694, 0.154068, 0.286694, -0.05211, 0.231435, -0.220664, -0.132272, -0.014687, -0.080668, 0.119329, 0.001925, 0.119329, -0.001925, -0.014687, 0.080668, -0.220664, 0.132272, 0.035011, -0.0, -0.006862, -0.0, 0.035011, -0.0, -0.006862, -0.0], 
	[-0.01668, -0.001281, -0.001075, 0.000885, -0.001075, -0.000885, -0.01668, 0.001281, 0.087306, 0.130415, -0.0586, 0.005566, 0.303269, 0.006311, 0.303269, -0.006311, -0.0586, -0.005566, 0.087306, -0.130415, -0.01668, -0.001281, -0.001075, 0.000885, -0.001075, -0.000885, -0.01668, 0.001281, 0.087306, 0.130415, -0.0586, 0.005566, 0.303269, 0.006311, 0.303269, -0.006311, -0.0586, -0.005566, 0.087306, -0.130415, -0.1385, -0.0, -0.489939, 0.0, -0.1385, -0.0, -0.489939, 0.0], 
	[-0.001547, 0.032033, 0.014547, 0.225569, 0.014569, -0.225573, -0.001547, -0.032037, -0.264113, 0.039913, -0.059876, 0.088136, 0.114619, 0.058148, 0.114619, -0.058153, -0.059876, -0.088141, -0.264113, -0.039913, -0.001547, 0.032033, 0.014547, 0.225569, 0.014569, -0.225573, -0.001547, -0.032037, -0.264113, 0.039913, -0.059876, 0.088136, 0.114619, 0.058148, 0.114619, -0.058153, -0.059876, -0.088141, -0.264113, -0.039913, 0.441511, -2e-06, -0.048796, 2.6e-05, 0.441511, -2e-06, -0.048796, 2.6e-05], 
	[-0.116438, -0.171449, 0.040009, 0.161019, 0.040019, -0.161019, -0.116438, 0.171449, 0.000331, 0.121429, 0.092511, -0.188548, -0.029835, -0.345137, -0.029835, 0.345137, 0.092511, 0.188548, 0.000331, -0.121429, -0.116438, -0.171449, 0.040009, 0.161019, 0.040019, -0.161019, -0.116438, 0.171449, 0.000331, 0.121429, 0.092511, -0.188548, -0.029835, -0.345137, -0.029835, 0.345137, 0.092511, 0.188548, 0.000331, -0.121429, 0.035224, -0.0, -0.008391, -0.0, 0.035224, -0.0, -0.008391, -0.0], 
	[-0.040885, 0.206352, -0.003009, -0.179491, -0.003009, 0.179491, -0.040885, -0.206352, -0.07098, -0.026929, 0.264392, 0.150091, -0.099428, -0.173811, -0.099428, 0.173811, 0.264392, -0.150091, -0.07098, 0.026929, -0.040885, 0.206352, -0.003009, -0.179491, -0.003009, 0.179491, -0.040885, -0.206352, -0.07098, -0.026929, 0.264392, 0.150091, -0.099428, -0.173811, -0.099428, 0.173811, 0.264392, -0.150091, -0.07098, 0.026929, 0.130801, -0.0, -0.230982, 0.0, 0.130801, -0.0, -0.230982, 0.0], 
	[-0.007504, -0.255098, 0.005248, 0.176989, 0.005248, -0.176989, -0.007504, 0.255098, 0.013901, -0.149019, 0.235688, 0.114329, -0.10799, 0.167939, -0.10799, -0.167939, 0.235688, -0.114329, 0.013901, 0.149019, -0.007504, -0.255098, 0.005248, 0.176989, 0.005248, -0.176989, -0.007504, 0.255098, 0.013901, -0.149019, 0.235688, 0.114329, -0.10799, 0.167939, -0.10799, -0.167939, 0.235688, -0.114329, 0.013901, 0.149019, -0.082644, -0.0, -0.19604, 0.0, -0.082644, -0.0, -0.19604, 0.0], 
	[-0.301162, 0.062022, 0.051915, -0.055319, 0.051925, 0.055321, -0.301162, -0.06202, 0.130869, 0.079644, 0.079464, -0.20377, -0.05016, 0.229262, -0.05016, -0.22926, 0.079464, 0.203762, 0.130869, -0.079644, -0.301162, 0.062022, 0.051915, -0.055319, 0.051925, 0.055321, -0.301162, -0.06202, 0.130869, 0.079644, 0.079464, -0.20377, -0.05016, 0.229262, -0.05016, -0.22926, 0.079464, 0.203762, 0.130869, -0.079644, 0.2131, 1e-06, -0.034962, 1e-06, 0.2131, 1e-06, -0.034962, 1e-06], 
	[0.236456, 0.052684, -0.034134, -0.01094, -0.034134, 0.01094, 0.236456, -0.052684, -0.202828, 0.193867, 0.153987, -0.242306, -0.065412, 0.126068, -0.065412, -0.126068, 0.153987, 0.242306, -0.202828, -0.193867, 0.236456, 0.052684, -0.034134, -0.01094, -0.034134, 0.01094, 0.236456, -0.052684, -0.202828, 0.193867, 0.153987, -0.242306, -0.065412, 0.126068, -0.065412, -0.126068, 0.153987, 0.242306, -0.202828, -0.193867, -0.118929, -0.0, -0.05721, -0.0, -0.118929, -0.0, -0.05721, -0.0]]
nb_euy = [[-0.068549, 0.172156, -0.019998, 0.206736, 0.019998, 0.206736, 0.068549, 0.172156, 0.081925, -0.035076, 0.077914, -0.10224, 0.060891, -0.344167, -0.060891, -0.344167, -0.077914, -0.10224, -0.081925, -0.035076, -0.068549, 0.172156, -0.019998, 0.206736, 0.019998, 0.206736, 0.068549, 0.172156, 0.081925, -0.035076, 0.077914, -0.10224, 0.060891, -0.344167, -0.060891, -0.344167, -0.077914, -0.10224, -0.081925, -0.035076, 0.0, 0.226586, -0.0, -0.021404, 0.0, 0.226586, -0.0, -0.021404],
 	[0.060248, 0.100897, -0.001075, 0.154426, 0.001075, 0.154426, -0.060248, 0.100897, -0.170816, -0.135877, -0.216515, -0.155696, -0.159216, 0.128747, 0.159216, 0.128747, 0.216515, -0.155696, 0.170816, -0.135877, 0.060248, 0.100897, -0.001075, 0.154426, 0.001075, 0.154426, -0.060248, 0.100897, -0.170816, -0.135877, -0.216515, -0.155696, -0.159216, 0.128747, 0.159216, 0.128747, 0.216515, -0.155696, 0.170816, -0.135877, 0.0, 0.115107, -0.0, -0.300102, 0.0, 0.115107, -0.0, -0.300102],
  	[-0.243211, 0.014581, -0.049714, -0.046099, 0.049714, -0.046099, 0.243211, 0.014581, 0.31774, -0.065179, 0.0506, -0.103108, 0.022606, 0.214721, -0.022606, 0.214721, -0.0506, -0.103108, -0.31774, -0.065179, -0.243211, 0.014581, -0.049714, -0.046099, 0.049714, -0.046099, 0.243211, 0.014581, 0.31774, -0.065179, 0.0506, -0.103108, 0.022606, 0.214721, -0.022606, 0.214721, -0.0506, -0.103108, -0.31774, -0.065179, -0.0, 0.12931, -0.0, -0.159148, -0.0, 0.12931, -0.0, -0.159148],
   	[-0.080668, 0.014687, 0.001925, -0.119329, -0.001925, -0.119329, 0.080668, 0.014687, 0.132272, 0.220664, -0.231435, 0.05213, -0.286694, -0.154068, 0.286694, -0.154068, 0.231435, 0.05211, -0.132272, 0.220664, -0.080668, 0.014687, 0.001925, -0.119329, -0.001925, -0.119329, 0.080668, 0.014687, 0.132272, 0.220664, -0.231435, 0.05213, -0.286694, -0.154068, 0.286694, -0.154068, 0.231435, 0.05211, -0.132272, 0.220664, -0.0, 0.006862, -0.0, -0.035011, -0.0, 0.006862, -0.0, -0.035011], 
   	[0.005566, 0.0586, 0.006311, -0.303269, -0.006311, -0.303269, -0.005566, 0.0586, -0.130415, -0.087306, -0.001281, 0.01668, 0.000885, 0.001075, -0.000885, 0.001075, 0.001281, 0.01668, 0.130415, -0.087306, 0.005566, 0.0586, 0.006311, -0.303269, -0.006311, -0.303269, -0.005566, 0.0586, -0.130415, -0.087306, -0.001281, 0.01668, 0.000885, 0.001075, -0.000885, 0.001075, 0.001281, 0.01668, 0.130415, -0.087306, 0.0, 0.489939, -0.0, 0.1385, 0.0, 0.489939, -0.0, 0.1385],
    [0.088136, 0.059876, 0.058148, -0.114619, -0.058153, -0.114619, -0.088141, 0.059876, -0.039908, 0.264113, 0.032033, 0.001547, 0.225569, -0.014547, -0.225573, -0.014569, -0.032037, 0.001547, 0.039908, 0.264113, 0.088136, 0.059876, 0.058148, -0.114619, -0.058153, -0.114619, -0.088141, 0.059876, -0.039908, 0.264113, 0.032033, 0.001547, 0.225569, -0.014547, -0.225573, -0.014569, -0.032037, 0.001547, 0.039908, 0.264113, 2.6e-05, 0.048796, -2e-06, -0.441511, 2.6e-05, 0.048796, -2e-06, -0.441511], 
    [-0.188548, -0.092511, -0.345137, 0.029835, 0.345137, 0.029835, 0.188548, -0.092511, -0.121429, -0.000331, -0.171449, 0.116438, 0.161019, -0.040009, -0.161019, -0.040019, 0.171449, 0.116438, 0.121429, -0.000331, -0.188548, -0.092511, -0.345137, 0.029835, 0.345137, 0.029835, 0.188548, -0.092511, -0.121429, -0.000331, -0.171449, 0.116438, 0.161019, -0.040009, -0.161019, -0.040019, 0.171449, 0.116438, 0.121429, -0.000331, -0.0, 0.008391, -0.0, -0.035224, -0.0, 0.008391, -0.0, -0.035224], 
    [0.150091, -0.264392, -0.173811, 0.099428, 0.173811, 0.099428, -0.150091, -0.264392, 0.026929, 0.07098, 0.206352, 0.040885, -0.179491, 0.003009, 0.179491, 0.003009, -0.206352, 0.040885, -0.026929, 0.07098, 0.150091, -0.264392, -0.173811, 0.099428, 0.173811, 0.099428, -0.150091, -0.264392, 0.026929, 0.07098, 0.206352, 0.040885, -0.179491, 0.003009, 0.179491, 0.003009, -0.206352, 0.040885, -0.026929, 0.07098, 0.0, 0.230982, -0.0, -0.130801, 0.0, 0.230982, -0.0, -0.130801], 
    [0.114329, -0.235688, 0.167939, 0.10799, -0.167939, 0.10799, -0.114329, -0.235688, 0.149019, -0.013901, -0.255098, 0.007504, 0.176989, -0.005248, -0.176989, -0.005248, 0.255098, 0.007504, -0.149019, -0.013901, 0.114329, -0.235688, 0.167939, 0.10799, -0.167939, 0.10799, -0.114329, -0.235688, 0.149019, -0.013901, -0.255098, 0.007504, 0.176989, -0.005248, -0.176989, -0.005248, 0.255098, 0.007504, -0.149019, -0.013901, 0.0, 0.19604, -0.0, 0.082644, 0.0, 0.19604, -0.0, 0.082644], 
    [-0.20377, -0.079464, 0.229262, 0.05016, -0.22926, 0.05016, 0.203762, -0.079464, -0.079646, -0.130869, 0.062022, 0.301162, -0.055319, -0.051915, 0.055321, -0.051925, -0.06202, 0.301162, 0.079646, -0.130869, -0.20377, -0.079464, 0.229262, 0.05016, -0.22926, 0.05016, 0.203762, -0.079464, -0.079646, -0.130869, 0.062022, 0.301162, -0.055319, -0.051915, 0.055321, -0.051925, -0.06202, 0.301162, 0.079646, -0.130869, 1e-06, 0.034962, 1e-06, -0.2131, 1e-06, 0.034962, 1e-06, -0.2131], 
    [-0.242306, -0.153987, 0.126068, 0.065412, -0.126068, 0.065412, 0.242306, -0.153987, -0.193867, 0.202828, 0.052684, -0.236456, -0.01094, 0.034134, 0.01094, 0.034134, -0.052684, -0.236456, 0.193867, 0.202828, -0.242306, -0.153987, 0.126068, 0.065412, -0.126068, 0.065412, 0.242306, -0.153987, -0.193867, 0.202828, 0.052684, -0.236456, -0.01094, 0.034134, 0.01094, 0.034134, -0.052684, -0.236456, 0.193867, 0.202828, -0.0, 0.05721, -0.0, 0.118929, -0.0, 0.05721, -0.0, 0.118929]]
nb_a1g = [[-0.058063, 0.195301, -0.014001, 0.233131, 0.014001, 0.233131, 0.058063, 0.195301, 0.094992, 0.094992, 0.195301, 0.058063, 0.233131, 0.014001, 0.233131, -0.014001, 0.195301, -0.058063, 0.094992, -0.094992, 0.058063, -0.195301, 0.014001, -0.233131, -0.014001, -0.233131, -0.058063, -0.195301, -0.094992, -0.094992, -0.195301, -0.058063, -0.233131, -0.014001, -0.233131, 0.014001, -0.195301, 0.058063, -0.094992, 0.094992, 0.0, 0.199581, 0.199581, 0.0, 0.0, -0.199581, -0.199581, 0.0], 
	[0.152211, 0.011962, 0.009042, 0.134261, -0.009042, 0.134261, -0.152211, 0.011962, -0.288622, -0.288622, 0.011962, -0.152211, 0.134261, -0.009042, 0.134261, 0.009042, 0.011962, 0.152211, -0.288622, 0.288622, -0.152211, -0.011962, -0.009042, -0.134261, 0.009042, -0.134261, 0.152211, -0.011962, 0.288622, 0.288622, -0.011962, 0.152211, -0.134261, 0.009042, -0.134261, -0.009042, -0.011962, -0.152211, 0.288622, -0.288622, -0.0, 0.023581, 0.023581, -0.0, -0.0, -0.023581, -0.023581, -0.0], 
	[-0.015246, 0.062216, -0.001077, -0.20855, 0.001077, -0.20855, 0.015246, 0.062216, -0.084666, -0.084666, 0.062216, 0.015246, -0.20855, 0.001077, -0.20855, -0.001077, 0.062216, -0.015246, -0.084666, 0.084666, 0.015246, -0.062216, 0.001077, 0.20855, -0.001077, 0.20855, -0.015246, -0.062216, 0.084666, 0.084666, -0.062216, -0.015246, 0.20855, -0.001077, 0.20855, 0.001077, -0.062216, 0.015246, 0.084666, -0.084666, -0.0, 0.374791, 0.374791, -0.0, -0.0, -0.374791, -0.374791, -0.0], 
	[-0.179499, -0.106499, -0.267749, 0.047804, 0.267749, 0.047804, 0.179499, -0.106499, -0.083814, -0.083814, -0.106499, 0.179499, 0.047804, 0.267749, 0.047804, -0.267749, -0.106499, -0.179499, -0.083814, 0.083814, 0.179499, 0.106499, 0.267749, -0.047804, -0.267749, -0.047804, -0.179499, 0.106499, 0.083814, 0.083814, 0.106499, -0.179499, -0.047804, -0.267749, -0.047804, 0.267749, 0.106499, 0.179499, 0.083814, -0.083814, 0.0, 0.029623, 0.029623, 0.0, 0.0, -0.029623, -0.029623, 0.0], 
	[0.163571, -0.233512, -0.027656, 0.082319, 0.027656, 0.082319, -0.163571, -0.233512, 0.123751, 0.123751, -0.233512, -0.163571, 0.082319, 0.027656, 0.082319, -0.027656, -0.233512, 0.163571, 0.123751, -0.123751, -0.163571, 0.233512, 0.027656, -0.082319, -0.027656, -0.082319, 0.163571, 0.233512, -0.123751, -0.123751, 0.233512, 0.163571, -0.082319, -0.027656, -0.082319, 0.027656, 0.233512, -0.163571, -0.123751, 0.123751, 0.0, 0.204261, 0.204261, 0.0, 0.0, -0.204261, -0.204261, 0.0], 
	[-0.200601, -0.14083, 0.229161, 0.073415, -0.229161, 0.073415, 0.200601, -0.14083, -0.066894, -0.066894, -0.14083, 0.200601, 0.073415, -0.229161, 0.073415, 0.229161, -0.14083, -0.200601, -0.066894, 0.066894, 0.200601, 0.14083, -0.229161, -0.073415, 0.229161, -0.073415, -0.200601, 0.14083, 0.066894, 0.066894, 0.14083, -0.200601, -0.073415, 0.229161, -0.073415, -0.229161, 0.14083, 0.200601, 0.066894, -0.066894, 0.0, 0.07137, 0.07137, 0.0, 0.0, -0.07137, -0.07137, 0.0]]
nb_a2g = [[0.137494, -0.166707, -0.122566, -0.142476, -0.122568, 0.142474, 0.137492, 0.166709, 0.049842, -0.049842, -0.166707, -0.137494, -0.142476, 0.122566, 0.142474, 0.122568, 0.166709, -0.137492, -0.049842, -0.049842, -0.137494, 0.166707, 0.122566, 0.142476, 0.122568, -0.142474, -0.137492, -0.166709, -0.049842, 0.049842, 0.166707, 0.137494, 0.142476, -0.122566, -0.142474, -0.122568, -0.166709, 0.137492, 0.049842, 0.049842, 0.284599, 2e-06, 2e-06, -0.284599, -0.284599, 2e-06, 2e-06, 0.284599], 
	[0.068245, 0.167927, -0.210506, 0.159376, -0.210533, -0.159339, 0.068217, -0.167939, 0.145569, -0.145544, 0.167927, -0.068245, 0.159376, 0.210506, -0.159339, 0.210533, -0.167939, -0.068217, -0.145569, -0.145544, -0.068245, -0.167927, 0.210506, -0.159376, 0.210533, 0.159339, -0.068217, 0.167939, -0.145569, 0.145544, -0.167927, 0.068245, -0.159376, -0.210506, 0.159339, -0.210533, 0.167939, 0.068217, 0.145569, 0.145544, 0.049863, -4e-06, -4e-06, -0.049863, -0.049863, -4e-06, -4e-06, 0.049863], 
	[-0.049814, -0.001008, 0.041208, 0.198017, 0.04124, -0.19801, -0.049814, 0.001, -0.192227, 0.192258, -0.001008, 0.049814, 0.198017, -0.041208, -0.19801, -0.04124, 0.001, 0.049814, 0.192227, 0.192258, 0.049814, 0.001008, -0.041208, -0.198017, -0.04124, 0.19801, 0.049814, -0.001, 0.192227, -0.192258, 0.001008, -0.049814, -0.198017, 0.041208, 0.19801, 0.04124, -0.001, -0.049814, -0.192227, -0.192258, 0.298837, 2.4e-05, 2.4e-05, -0.298837, -0.298837, 2.4e-05, 2.4e-05, 0.298837], 
	[-0.070651, 0.251006, 0.007917, -0.205232, 0.007934, 0.205231, -0.070672, -0.251, -0.051452, 0.051448, 0.251006, 0.070651, -0.205232, -0.007917, 0.205231, -0.007934, -0.251, 0.070672, 0.051452, 0.051448, 0.070651, -0.251006, -0.007917, 0.205232, -0.007934, -0.205231, 0.070672, 0.251, 0.051452, -0.051448, -0.251006, -0.070651, 0.205232, 0.007917, -0.205231, 0.007934, 0.251, -0.070672, -0.051452, -0.051448, 0.156041, -6e-06, -6e-06, -0.156041, -0.156041, -6e-06, -6e-06, 0.156041], 
	[-0.259227, -0.06502, 0.038215, 0.015906, 0.038215, -0.015907, -0.259226, 0.065026, 0.208719, -0.208714, -0.06502, 0.259227, 0.015906, -0.038215, -0.015907, -0.038215, 0.065026, 0.259226, -0.208719, -0.208714, 0.259227, 0.06502, -0.038215, -0.015906, -0.038215, 0.015907, 0.259226, -0.065026, -0.208719, 0.208714, 0.06502, -0.259227, -0.015906, 0.038215, 0.015907, 0.038215, -0.065026, -0.259226, 0.208719, 0.208714, 0.128822, -1e-06, -1e-06, -0.128822, -0.128822, -1e-06, -1e-06, 0.128822]]

ipbases  = [nb_b2g, nb_b1g, nb_eux, nb_euy, nb_a1g, nb_a2g]
ip_comp_base_num = [[0,6],[6,12],[12,23],[23,34],[34,40],[40,45]]

#the in plane equivalent functions, which are explained above

def gen_linalg_ip_min(xymat):
	xy_diff_mat = np.matrix(np.subtract(xymat, ref_str_mat[:,0:2]).flatten()).transpose()
	bigmat = np.vstack(([x[0] for x in ipbases])).transpose()
	linalgdata = np.linalg.lstsq(bigmat, xy_diff_mat,rcond = None)
	linalg_dip = np.sqrt(np.sum(np.square(linalgdata[0])))
	linalgout = np.array(np.hstack((linalgdata[0].transpose()[0],[[linalg_dip]],linalgdata[1]/4))).flatten()
	return linalgout

def gen_linalg_ip_ext(xymat):
	xy_diff_mat = np.matrix(np.subtract(xymat, ref_str_mat[:,0:2]).flatten()).transpose()
	bigmat = np.vstack(([x[0:2] for x in ipbases])).transpose()
	linalgdata = np.linalg.lstsq(bigmat, xy_diff_mat,rcond = None)
	linalg_dip = np.sqrt(np.sum(np.square(linalgdata[0])))
	linalgout = np.array(np.hstack((linalgdata[0].transpose()[0],[[linalg_dip]],linalgdata[1]/4))).flatten()
	return linalgout

def gen_linalg_ip_comp(xymat):
	xy_diff_mat = np.matrix(np.subtract(xymat, ref_str_mat[:,0:2]).flatten()).transpose()
	bigmat = np.vstack((ipbases)).transpose()
	linalgdata = np.linalg.lstsq(bigmat, xy_diff_mat,rcond = None)
	linalgsum = []
	for i in ip_comp_base_num:
		linalgsum.append(np.sqrt(np.sum(np.square(linalgdata[0][i[0]:i[1]]))))
	linalg_dip = np.sqrt(np.sum(np.square(linalgdata[0])))
	linalgout = np.array(np.hstack(([linalgsum],[[linalg_dip]],linalgdata[1]/4))).flatten()
	return linalgout

def gen_linalg_ip_total(xymat):
	xy_diff_mat = np.matrix(np.subtract(xymat, ref_str_mat[:,0:2]).flatten()).transpose()
	bigmat = np.vstack((ipbases)).transpose()
	linalgdata = np.linalg.lstsq(bigmat, xy_diff_mat,rcond = None)
	linalg_dip = np.sqrt(np.sum(np.square(linalgdata[0])))
	linalgout = np.array(np.hstack((linalgdata[0].transpose()[0],[[linalg_dip]],linalgdata[1]/4))).flatten()
	return linalgout

# A method of rounding numbers in an uneven matrix, and replacing -0 with 0, for purely aesthetic reasons

trim_list = lambda x :  [z if z!='-0.00' else '0.00' for z in ['{:.2f}'.format(round(y, 2)) for y in x]]
trim_list_3 = lambda x :  [z if z!='-0.000' else '0.000' for z in ['{:.3f}'.format(round(y, 3)) for y in x]]

# takes an x,y,z- matrix (xyzmat.shape = 24*3), and returns the NSD result, which is a list of ordered, variable length lists
#which represent the total NSD matrix. This is the input for the HTML output and for each of the tests in porphyrin_tests

def gen_nsd_from_atoms_w_tot(xyzmat, trim_func = trim_list):
	#runs the nsd stuff on a properly ordered and fitted matrix 
	ip1 = gen_linalg_ip_min(xyzmat[:,0:2]).tolist()
	ip2 = gen_linalg_ip_ext(xyzmat[:,0:2]).tolist()
	ip3 = gen_linalg_ip_comp(xyzmat[:,0:2]).tolist()
	ip4 = gen_linalg_ip_total(xyzmat[:,0:2]).tolist()
	oop1 = gen_linalg_oop_min(xyzmat[:,2]).tolist()
	oop2 = gen_linalg_oop_ext(xyzmat[:,2]).tolist()
	oop3 = gen_linalg_oop_comp(xyzmat[:,2]).tolist()
	oop4 = gen_linalg_oop_total(xyzmat[:,2]).tolist()
	nsd_matrix = [trim_func(x) for x in [ip1,ip2,ip3,ip4,oop1,oop2,oop3,oop4]]
	return nsd_matrix

	
ref_str_mat	= np.matrix(np.array([ -1.09, 2.827, 0.0, -0.6767, 4.203, 0.0,  0.6767, 4.203, 0.0, 1.09, 2.827, 0.0, 2.413,2.413,0.0,2.827, 1.09, 0.0, 4.203, 0.6767, 0.0,4.203, -0.6767, 0.0,2.827, -1.09, 0.0, 2.413,-2.413,0.0, 1.09, -2.827, 0.0, 0.6767, -4.203, 0.0,  -0.6767, -4.203, 0.0, -1.09, -2.827, 0.0, -2.413,-2.413,0.0, -2.827,-1.09,0.0,  -4.203, -0.6767, 0.0,  -4.203, 0.6767, 0.0,  -2.827, 1.09, 0.0, -2.413,2.413,0.0, 0.0,1.998,0.0, 1.998,0.0,0.0, 0.0,-1.998,0.0, -1.998,0.0,0.0]).reshape(24,3))
#the CuTPP structure used for the basis of NSD. CUTPOR02 in the CCDC. as a 24*3 matrix
#used throughout


#this entire section is for making atom position lists with specific distortion profiles for external analysis
# shared with Lukas Urmstul at Talinn - 202005

ng = lambda x,n: [x+str(i+1) for i in range(n)]
ip_names = ng('b2g',6)+ng('b1g',6)+ng('eux',11)+ng('euy',11)+ng('a1g',6)+ng('a2g',5)
op_names = ng('b2u',3)+ng('b1u',3)+ng('a2u',3)+ng('egx',5)+ng('egy',5)+ng('a1u',2)

oop_matrify = lambda mat1d : np.vstack((np.zeros(24), np.zeros(24), np.array(mat1d).flatten())).T
ip_matrify = lambda mat2d : np.vstack((np.array(mat2d[::2]).flatten(),np.array(mat2d[1::2]).flatten(),np.zeros(24))).T

opbs = np.array([oop_matrify(x) for x in np.hstack([nb_b2u, nb_b1u, nb_a2u, nb_egx, nb_egy, nb_a1u]).T])
ipbs = np.array([ip_matrify(x) for x in np.vstack([nb_b2g, nb_b1g, nb_eux, nb_euy, nb_a1g, nb_a2g])])

base_names = ip_names + op_names
base_mats  = np.vstack((ipbs,opbs))
uvec = lambda vec: vec/norm(vec)
ext_bisec = lambda v1,v2,v3,d: v2+(float(d)*uvec(uvec(v2-v1)+uvec(v2-v3)))
	
def add_h(mat, dist = 0.83): # adds hydrogen to a porphyrin, at the external bisector, with d = 0.83 A 
	hpos = []
	for i in [2,3,5,7,8,10,12,13,15,17,18,20]:
		a,b,c = mat[i-2],mat[i-1],mat[i%20]
		hpos.append(ext_bisec(a,b,c,dist))
	return np.vstack([mat, np.vstack(hpos)])

def add_m(mat, dist = 2.0): # adds metal to a porphyrin, at the mean of the nitrogen external bisectors, with d = 2.0 A 
	n_bisec = []
	for i in [[1,21,4],[6,22,9],[11,23,14],[16,24,19]]:
		a,b,c = mat[i[0]-1],mat[i[1]-1],mat[i[2]-1]
		n_bisec.append(ext_bisec(a,b,c,dist))
	metal_pos = np.mean(np.vstack(n_bisec),axis = 0)
	return np.vstack([mat, metal_pos])

def print_gaussian_input(mat, metal_name = 'M'):
	asyms =  ['C']*20+['N']*4+['H']*12+[metal_name]
	if mat.shape[0] == 25: 
		asyms = ['C']*20+['N']*4+[metal_name]
	glis = [n + '  ' + '  '.join([str(x) for x in np.array(a).flatten()]) for a,n in zip(mat, asyms)]
	return('\n'.join(glis))

nsd_dict_gen   = lambda: {name:0 for name in base_names}

#e.g. s = ref_str_mat + np.sum([mat * nsd_dict[nm] for mat,nm in zip(base_mats, base_names)], axis = 0)
# generates a matrix which represents the porphyrin structure

# connectivity lists, which descrive an ordered porphyrin matrix as a series of bonds, for plotting purposes. 
#1 is for a x,y- style porphyrin plot and 2 is for z-theta style after the cylindrical coordinate transfer. 
#The h- included ones are those generated above by add_h command.

porp_c1  = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 20, 3, 4, 5, 21, 8, 9, 10, 22, 13, 14, 15, 23, 18]
porp_c2  = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 22, 10, 9, 8, 21, 5, 4, 3, 20, 0, 19, 18, 23, 15, 14, 15, 16, 17, 18, 19, 0]
porp_c1h = [0, 1, 24, 1, 2, 25, 2, 3, 4,26,4, 5, 6, 27, 6, 7, 28, 7, 8, 9,29,9, 10, 11, 30, 11, 12, 31, 12, 13, 14, 32, 14, 15, 16, 33, 16, 17, 34, 17, 18, 19, 35, 19, 0, 20, 3, 4, 5, 21, 8, 9, 10, 22, 13, 14, 15, 23, 18]
porp_c2h = [0, 1, 24, 1, 2, 25, 2, 3, 4,26,4, 5, 6, 27, 6, 7, 28, 7, 8, 9,29,9, 10, 11, 30, 11, 12, 31, 12, 13, 22, 10, 9, 8, 21, 5, 4, 3, 20, 0, 19, 18, 23, 15, 14, 15, 16, 33, 16, 17, 34, 17, 18, 19, 35, 19, 0]

#cylindrical coordinate transform, which is necessary for the skeletal plot, and for making rational skeletal plots, 
#rather than those which relied on precomputed values (not that there's anything wrong with that.)
#they're used in the plots and in the interactive figures which have been sent around.

cc_transform_thetaonly = lambda mat: np.array((np.arctan2(mat[:,1],mat[:,0])+2.2)%6.283-2.98)
cc_transform_thetaonly_deg = lambda mat: np.degrees(np.array((np.arctan2(mat[:,1],mat[:,0])+2.2)%6.28318-2.98539))
cc_transform_ronly = lambda mat: np.matrix(norm(mat[:,0:2], axis = 1)).T


#little lambdas which take a matrix and decompose into one-dimensional arrays - just a little cleaner than 
# putting multi-line plotting commands and stuff, and they're used frequently. +h are for the H-atoms commands
# described above

gen_x = lambda mat: np.array([mat[x,0] for x in porp_c1])
gen_y = lambda mat: np.array([mat[x,1] for x in porp_c1])
gen_z = lambda mat: np.array([mat[x,2] for x in porp_c2])
gen_t = lambda mat: [cc_transform_thetaonly(mat)[i] for i in porp_c2]
gen_t_deg = lambda mat: [cc_transform_thetaonly_deg(mat)[i] for i in porp_c2]

gen_xh = lambda mat: np.array([mat[x,0] for x in porp_c1h])
gen_yh = lambda mat: np.array([mat[x,1] for x in porp_c1h])
gen_zh = lambda mat: np.array([mat[x,2] for x in porp_c2h])
gen_th = lambda mat: [cc_transform_thetaonly(mat)[i] for i in porp_c2h]

#import file functions

#imports a pdb. Vulnerable to moving decimal places, needs a rewrite.
# should be the fixed version, from the file definitions. Had issues with importing 'ANISOU'
#ignores everything more than x angstroms from a nitrogen atom, and non- C,N atoms. 
# can be removed, but tends to mess with stuff and increase computation time and, as is, is
# compatible with chlorins, bacteriochlorins, phthalocyanines and etc. 

def import_pdb(filelist, magic_n_radius = 2.75):
	co_list, at_list = [], []
	
	for l in filelist:
		if len(l)>55 and l.split()[-1] in ['C','N'] and l.startswith(('HETATM','ATOM')):
			x,y,z = l[31:39],l[39:47],l[47:55]
			at_list.append(l.split()[-1])
			co_list.append([float(v) for v in [x,y,z]])
	n_coords = [coords for at,coords in zip(at_list,co_list) if at == 'N']
	co_list_2 = [coords for at,coords in zip(at_list,co_list) if min([atomdist_2(coords,n) for n in n_coords])<magic_n_radius]
	return np.array(co_list_2)
# now only imports coords within magic distance of a nitrogen
import_pdb_f   = lambda filenm : import_pdb(open(filenm,'r'))
# runs the above on a file. will need another version for non-filename versions (text field, online w.direct (not saving))
#online works without modification. PythonAnywhere standard install. Plan to upgrade for access to PDF printing.
# 202008 - upgraded. The PDF printing is still a little off and ignoring instructions, but it works. Cairo is pretty bad to work with, apparently.

#Transforms used
# SUPER IMPORTANT Quaternions here are not the normal [w,xi,yj,zk] that you know and love, but instead weird 
# [x,y,z,w] quaternions which such and are terrible and wasted like three days of mine but are also awesome. s.o. to my boy Hamilton.
# This only works okay because we don't write the Quaternions directly and instead get them from the same runtime we give them to,
# so that saves things. See Mondrian - Headless for the actual waste of my time

trans_atoms	= lambda xyzmat, vector: np.matrix([np.array((vector + x)).flatten() for x in xyzmat])
#translates an atom matrix (n*3) by a vector (len 3)
rot_atoms	  = lambda xyzmat, quater: np.matrix([R.from_quat(quater).apply(x).flatten() for x in xyzmat])
#rotates an atom matrix by a quaternion (in [xyzw] notation!)
inv_rot_atoms  = lambda xyzmat, quater: np.matrix([R.from_quat(quater).inv().apply(x).flatten() for x in xyzmat])
#rotates an atom matrix by the inverse of a quaternion i.e. rotates back, so [x,y,z, -w]
rt_atoms	   = lambda params, xyzmat: trans_atoms(rot_atoms(xyzmat, params[3:7]),params[0:3])
#combines rotation and translation. This is the minimization function basis set before (See Acta Cryst A )
inv_rt_atoms   = lambda params, xyzmat: inv_rot_atoms(trans_atoms(xyzmat,[-x for x in params[0:3]]), params[3:7])
#inverts a rotation and translation. Should work, has been tested
#order of operations turned out to be very important, and screwed everything up. In my defense, I failed second year methematics.

#sum square functions used for minimize fits
mpln_fit	   = lambda quater, xyzmat: np.sum(np.square(rot_atoms(xyzmat,quater))[:,2])
plane_rot_fit  = lambda theta, xyzmat: mat_dist_4(rot_atoms(xyzmat,[np.cos(theta/2),np.sin(theta/2),0,0])[:,0:2],ref_str_mat[:,0:2])**2
normalise_atoms = lambda xyzmat: xyzmat-np.mean(xyzmat, axis = 0)
#moves atoms to the centre of 'mass' with all atoms equally weighted
atomdist_2	 = lambda a1,a2: np.sqrt(np.sum(np.square(np.array(a1) - np.array(a2))))
#gives the distance in real space between two vectors. object/non-object versions.

def mat_dist_4(m1,m2): 
	a = np.array([np.array(np.meshgrid(c1,c2)) for c1,c2 in zip(np.array(m1.T),np.array(m2.T))])
	return np.sum(np.min(np.sum(np.square(a[:,1]-a[:,0]),axis = 0),axis = 0))
	
#gives the sum of square difference for the closes two atoms which reside in two matrices. 
#this is the critical component of the least squares fit to an arbitrary structure
# _4 is a significant speed improvement, able to run in a fraction of the time (2s - 0.1 s)

rotfunc_4	  = lambda params, mats: mat_dist_4(rt_atoms(params, mats[0]),mats[1])
#implements the above for fitting to a porphyrin(3) or an arbitrary distorted porphyrin(4)


#these are the plots which appear at the base of the NSD profile - each lambda is run in the gen_nsd_fig function, and
#next plan is to incorporate handling of ellipsoid data in to there. Not sure exactly whether there's an easier way to pass a bunch
#of specs to a plot.

#plotting functions for easy generation of matplotlib indicators
plot_atoms_xy  = lambda xyzmat,**args: plt.plot(xyzmat[:,0],xyzmat[:,1],'o',linestyle = 'none',**args)
#generates an xy pyplot

porp_connect   = lambda xyzmat: np.vstack([xyzmat[i] for i in porp_c1])
#turns a porphyrin C1-C20-N21-N24 grid to an ordered list so that the skeletal plot can be plotted.
plot_xy_wlines = lambda xyzmat, **args: plt.plot(porp_connect(xyzmat)[:,0],porp_connect(xyzmat)[:,1],**args)
plot_xy_wlines_ax = lambda xyzmat, ax, **args: ax.plot(porp_connect(xyzmat)[:,0],porp_connect(xyzmat)[:,1],**args)
#plots the 'xy' skeletal plot. plt/ax versions for notebook work

skel_dev_plot_2  = lambda xyzmat,**args: plt.plot(gen_t(xyzmat), gen_z(xyzmat), **args)
skel_dev_plot_2_ax  = lambda xyzmat, ax, **args: ax.plot(gen_t_deg(xyzmat), gen_z(xyzmat), **args)
#plots the 'z-theta' skeletal plot. plt/ax versions for notebook work

skel_dev_plot_2N = lambda xyzmat,**args: plt.plot(cc_transform_thetaonly(xyzmat)[20:], xyzmat[20:,2], linestyle = 'none',**args)
skel_dev_plot_2N_ax = lambda xyzmat, ax, **args: ax.plot(cc_transform_thetaonly_deg(xyzmat)[20:], xyzmat[20:,2], linestyle = 'none',**args)
#plots the N atoms of the 'z-theta' skeletal plot. plt/ax versions for notebook work

def gen_nsd_fig(coords, imagepath):	
	fig, (ax1, ax2) = plt.subplots(1,2, figsize=(10.5,5))
	plot_xy_wlines_ax(ref_str_mat, ax1, marker = 'o',linestyle = 'dotted', color = 'red')
	plot_xy_wlines_ax(coords, ax1, marker = 'o',color = 'black')
	
	ax1.plot(coords[20:,0],coords[20:,1], linestyle = 'none', marker = 'o',color = 'blue')
	ax1.set_title('In-plane distortion')
	ax1.set_xlabel(r'x position ($\AA$)')
	ax1.set_ylabel(r'y position ($\AA$)')
	
	ax2.plot([-180,180],[0,0], linestyle = 'dotted', color = 'red')
	skel_dev_plot_2_ax(coords, ax2, marker = 'o', color = 'black')
	skel_dev_plot_2N_ax(coords, ax2, marker = 'o', color = 'blue')
	maxz = np.max(np.abs(coords[:,2]))
	ax2.set_xlim(-190,190)
	ax2.set_xticks([-180,-90,0,90,180])
	if maxz <1 :
		ax2.set_ylim(-1,1)
		ax2.set_yticks([-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])
	else: ax2.set_ylim(-maxz-0.5,maxz+0.5)
	ax2.set_title('Out-of-plane distortion')
	ax2.set_xlabel(r'Angle in Cylindrical coordinates ($\degree$)')
	ax2.set_ylabel(r'z position ($\AA$)')
	ax2.yaxis.set_label_position("right")
	ax2.yaxis.tick_right()
	plt.subplots_adjust(left = 0.07, right = 0.93, wspace = 0.1, top = 0.95)
	fig.savefig(imagepath, dpi = 300)
	plt.clf()

def fit_atoms_rt(xyzmat, refmat = ref_str_mat, cycles = 1):
	porpfit = [0,0,0,0.1,0,0,0]
	#this is x,y,z and a rotational quaternion - fitting rotation and translation concurrently, as the
	#centre of mass of the structure is not necessarily the centre of the porphyrin.
	for i in range(cycles):
		porpfit = minimize(rotfunc_4, porpfit, [refmat, xyzmat]).x
	return inv_rt_atoms(porpfit, xyzmat)

# _old may be useful for more distorted structures, just have to write an effective testing regime


#gen_fixed_xyz take a matrix representing atom positions and put them in the stated porphyrin structure order

#version 202007 (v6) - uses the Hungarian method for assigning atoms to the fixed structure, prevents the 'atom-doubling effect of the previous
#method (smallest distance). no real way to check that it's right - seems to give a characteristic atom number matrix that isn't just 1-24
#next step - implement some kind of check method.
#This algoritm is On^3 so pretty much immediate. 

def gen_fixed_xyz_v6(xyzmat, refmat = ref_str_mat):
	costmat = np.zeros((len(refmat[:,0]),len(xyzmat[:,0])))
	for idx_r,val_r in enumerate(refmat[:,0:2]):
		for idx_m,val_m in enumerate(xyzmat[:,0:2]):
			costmat[idx_r,idx_m] = atomdist_2(val_r,val_m)
	assignmat = linear_sum_assignment(costmat)[1].tolist()
	return (np.vstack([xyzmat[i] for i in assignmat]), assignmat)
	
def nsd_fit_out_v5(filenm, reference_matrix = ref_str_mat):
	raw_atoms = import_pdb_f(filenm)
	nor_atoms = normalise_atoms(raw_atoms)
	fit_atoms = fit_atoms_rt(nor_atoms, reference_matrix,1)
	num_porp  = gen_fixed_xyz_v6(fit_atoms, reference_matrix)[0]
	nor_porp  = normalise_atoms(num_porp)
	fit_porp  = fit_atoms_rt(nor_porp,reference_matrix,1)
	mpln	  = minimize(mpln_fit, [1,0,0,0], fit_porp).x
	mpln_porp = rot_atoms(fit_porp, mpln)
	theta	  = minimize(plane_rot_fit, 0, fit_porp).x
	rot_porp  = inv_rot_atoms(fit_porp,[np.cos(theta/2),np.sin(theta/2),0,0])
	xyz_final, ass_mat = gen_fixed_xyz_v6(rot_porp, reference_matrix)
	nsd	   = gen_nsd_from_atoms_w_tot(xyz_final, trim_list)
	return nsd, xyz_final, ass_mat
	
def save_figs_and_NSD(filepath, imagepath1):
	nsd_mat, coords, ass_mat = nsd_fit_out_v5(filepath, ref_str_mat)
	gen_nsd_fig(coords, imagepath1)
	return (nsd_mat, coords)

#extra little names for things - helps with the generation of NSD dataframes (i.e. NSD_x.pkl)
tg = lambda x,n: [x+str(i+1) for i in range(n)] 
tf = lambda x,n: [x+'f'+str(i+1) for i in range(n)] 

ip1_names = ['mstr', 'nstr', 'trnx', 'trny', 'bre', 'rot', 'dip', 'dip_err'] 
ip2_names = ['b2g_ext1', 'b2g_ext2', 'b1g_ext1', 'b1g_ext2', 'eux_ext1', 'eux_ext2', 'euy_ext1', 'euy_ext2', 'a1g_ext1', 'a1g_ext2', 'a2g_ext1', 'a2g_ext2', 'dip_ext', 'dip_ext_err'] 
ip3_names = ['b2g_comp', 'b1g_comp', 'eux_comp', 'euy_comp', 'a1g_comp', 'a2g_comp', 'dip_comp', 'dip_comp_err'] 
ip4_names = tg('b2gt',6)+tg('b1gt',6)+tg('euxt',11)+tg('euyt',11)+tg('a1gt',6)+tg('a2gt',5)+['dipt','dipt_err'] 
ip4f_names = tf('b2gt',6)+tf('b1gt',6)+tf('euxt',11)+tf('euyt',11)+tf('a1gt',6)+tf('a2gt',5)+['diptf','diptf_err'] 
ip4_firsts = [0]*6 + [6]*6 + [12]*11 + [23]*11 + [45]*6 + [40]*5 + [45,46] 
 
op1_names = ['sad', 'ruf', 'dom', 'wavx', 'wavy', 'pro', 'doop', 'doop_err']  
op2_names = ['b2u_ext1', 'b2u_ext2', 'b1u_ext1', 'b1u_ext2', 'a2u_ext1', 'a2u_ext2', 'egx_ext1', 'egx_ext2', 'egy_ext1', 'egy_ext2', 'a1u_ext1', 'a1u_ext2', 'doop_ext', 'doop_ext_err'] 
op3_names = ['b2u_comp', 'b1u_comp', 'a2u_comp', 'egx_comp', 'egy_comp', 'a1u_comp', 'doop_comp', 'doop_comp_err'] 
op4_names = tg('b2ut',3)+tg('b1ut',3)+tg('a2ut',3)+tg('egxt',5)+tg('egyt',5)+tg('a1ut',2)+['dopt','dopt_err'] 
op4f_names = tf('b2ut',3)+tf('b1ut',3)+tf('a2ut',3)+tf('egxt',5)+tf('egyt',5)+tf('a1ut',2)+['doptf','doptf_err'] 
op4_firsts = [0]*3 + [3]*3 + [6]*3 + [9]*5 + [14]*5 + [19]*2 + [21,22] 
 
nsd_names = [ip1_names,ip2_names ,ip3_names ,ip4_names ,op1_names ,op2_names ,op3_names ,op4_names,ip4f_names,op4f_names] 
all_modes_names = [x for y in nsd_names for x in y]

#from here on, this is the code which imports and plots the ANISOU card data for
#each of the atoms in the core. Basically the same as the above, and I'll
#combine them at some point. Desire is to put error margins on the NSD numbers 
#based on thermal activation.
#Handles thermal data, not certain that it has the right implementation of
#matrix multiplication for tensors (ellipsoids) yet. That will be the next issue

def gen_fixed_xyz_v4(xyzmat, refmat = ref_str_mat):
	assignmat = [0]*len(refmat[:,0])
	for idx_r,val_r in enumerate(refmat[:,0:2]):
		assignmat[idx_r] = np.argmin([atomdist_2(val_r,val_m) for val_m in xyzmat[:,0:2]])
	return (np.vstack([xyzmat[i] for i in assignmat]), assignmat)

def import_pdb_waniso(filelist, magic_n_radius = 3):
	co_list, at_list,aniso_list, ser_list = [], [], [], []
	
	for index, l in enumerate(filelist): #l is line
		if len(l)>55 and l.split()[-1] in ['C','N'] and l.startswith(('HETATM','ATOM')):
			serial,x,y,z = l[6:11],l[31:39],l[39:47],l[47:55]
			at_list.append(l.split()[-1])
			co_list.append([float(v) for v in [x,y,z]])
			ser_list.append(serial)
			if str(filelist[index+1]).startswith('ANISOU'):
				l2 = filelist[index+1]
				u11,u22,u33,u12,u13,u23 = l2[29:36],l2[36:43],l2[43:50],l2[50:57],l2[57:64],l2[64:71]
				aniso_list.append(np.array([u11,u22,u33,u12,u13,u23]).astype(float))
	n_coords = [coords for at,coords in zip(at_list,co_list) if at == 'N']
	co_list_2    = [coords for coords in co_list if min([atomdist_2(coords,n) for n in n_coords])<magic_n_radius]
	ser_list_2   = [serials for coords,serials in zip(co_list,ser_list) if min([atomdist_2(coords,n) for n in n_coords])<magic_n_radius]
	if len(aniso_list) > 0:
		aniso_list_2 = [anisos for coords,anisos in zip(co_list,aniso_list) if min([atomdist_2(coords,n) for n in n_coords])<magic_n_radius]
	else: 
		aniso_list_2 = []
	print(np.array(co_list_2))
	return np.array(co_list_2), np.array(aniso_list_2), ser_list_2
	
# now only imports coords within magic distance of a nitrogen
#incl anisotropic parameters too
import_pdb_waniso_f   = lambda filenm : import_pdb_waniso(open(filenm,'r').readlines())
# runs the above on a file. will need another version for non-filename versions (text field, online)

aniso_to_matrix = lambda ans : np.matrix([[ans[0],ans[3],ans[4]],[ans[3],ans[1],ans[5]],[ans[4],ans[5],ans[2]]])
rotate_tensor = lambda ansmat,quater : np.dot(np.dot(R.from_quat(quater).as_matrix(),ansmat), R.from_quat(quater).as_matrix().T)

def fit_atoms_rt_v2(xyzmat, refmat = ref_str_mat, cycles = 1):
	porpfit = [0,0,0,0.1,0,0,0]
	for i in range(cycles):
		porpfit = minimize(rotfunc_4, porpfit, [refmat, xyzmat]).x
	return inv_rt_atoms(porpfit, xyzmat),porpfit

def gen_fixed_xyz_v5(xyzmat, refmat = ref_str_mat):
	assignmat = [0]*len(refmat[:,0])
	for idx_r,val_r in enumerate(refmat[:,0:2]):
		assignmat[idx_r] = np.argmin([atomdist_2(val_r,val_m) for val_m in xyzmat[:,0:2]])
	return (np.vstack([xyzmat[i] for i in assignmat]), assignmat)

def nsd_fit_out_v4(filenm, reference_matrix = ref_str_mat, aniso_gen = True):
	if aniso_gen:
		raw_atoms, raw_anisos, serials = import_pdb_waniso_f(filenm)
	else:
		raw_atoms = import_pdb_f(filenm)
	nor_atoms = normalise_atoms(raw_atoms)
	fit_atoms, reorient_mat1 = fit_atoms_rt_v2(nor_atoms, reference_matrix,2)
	num_porp, assignmat1 = gen_fixed_xyz_v4(fit_atoms, reference_matrix)
	nor_porp  = normalise_atoms(num_porp)
	fit_porp, reorient_mat2 = fit_atoms_rt_v2(nor_porp,reference_matrix,2)
	mpln	  = minimize(mpln_fit, [1,0,0,0], fit_porp).x #reorient_mat3
	mpln_porp = rot_atoms(fit_porp, mpln)
	theta	  = minimize(plane_rot_fit, 0, fit_porp).x #reorient_mat4
	rot_porp  = inv_rot_atoms(fit_porp,[np.cos(theta/2),np.sin(theta/2),0,0])
	xyz_final, assignmat2 = gen_fixed_xyz_v4(rot_porp, reference_matrix)
	nsd	   = gen_nsd_from_atoms_w_tot(xyz_final, trim_list)
	
	if aniso_gen:
		sers_2 = [serials[i] for i in assignmat1]
		sers_3 = [sers_2[i] for i in assignmat2]
		anis_2 = [raw_anisos[i] for i in assignmat1]
		anis_3 = np.vstack([anis_2[i] for i in assignmat2])/1000
		deltas = np.vstack([rotate_tensor(rotate_tensor(rotate_tensor(rotate_tensor(aniso_to_matrix(x),reorient_mat1[3:7]),
			reorient_mat2[3:7]),mpln),[np.cos(theta/2),np.sin(theta/2),0,0]).flatten()[:,[0,4,8,1,2,5]] for x in anis_3])
	else:
		deltas = []
	print(assignmat2)
	return nsd, xyz_final, assignmat2, deltas
	
skel_dev_plot_2_ax_erbars = lambda xyzmat, dels, ax, thermal_sfac = 1.0,**args: ax.errorbar(gen_t_deg(xyzmat), gen_z(xyzmat), yerr= [thermal_sfac*dels[i,2] for i in porp_c2],linestyle = 'none',capsize = 4,**args)
plot_xy_erbars_ax = lambda xyzmat, dels, ax, **args: ax.errorbar(xyzmat[:,0],xyzmat[:,1],xerr = dels[:,0], yerr = dels[:,1],linestyle = 'none',capsize = 4, **args)
    
    # equation for an ellipse is cotangent(2*theta) = (A-C)/B for Ax^2 + Bxy + Cy^2 (A=u11, B=u12, C=u22)  
    # with major/ minor axes denoted by A' = A(cos θ)^2 + B(cos θ sin θ) + C(sin θ)^2
    #                                   B' = 0
    #                                   C' = A(sin θ)^2 − B(sin θ cos θ) + C(cos θ)^2
    
	#ellip_z_eq = lambda z, u33: np.abs(erf(2*np.pi*z/u33))
	#print(np.mean([ellip_z_eq(z,e) for z,e in zip(coords[:,2],deltas[:,2]/2)]))
	#print(coords[:,2],deltas[:,2]/2)
    
def draw_angle_errorbars(xpos,ypos, u11, u12, u22, ax,thermal_sfac=1.0, **args): #assumes z=0 plane for every individual atom (slice through atom centroid parallel to the mean plane)
    theta  = (1/2)*(np.arctan(u12/(u11-u22)))
    Aprime = u11*(np.cos(theta))**2 + u12*(np.cos(theta)*np.sin(theta)) + u22*(np.sin(theta))**2
    Bprime = -2*u11*(np.cos(theta)*np.sin(theta)) + u12*(np.cos(theta)**2-np.sin(theta)**2) + 2*u22*(np.cos(theta)*np.sin(theta))
    #Sanity check. Bprime should be zero
    Cprime = u11*(np.sin(theta))**2 - u12*(np.cos(theta)*np.sin(theta)) + u22*(np.cos(theta))**2
    v1x, v1y = thermal_sfac*Aprime*np.cos(-theta),  thermal_sfac*Aprime*np.sin(-theta)
    v2x, v2y = thermal_sfac*Cprime*np.sin(-theta),  thermal_sfac*(-Cprime)*np.cos(-theta)
    ax.annotate("", xytext=(xpos-v1x,ypos-v1y), xy=(xpos+v1x, ypos+v1y), 
                                 arrowprops=dict(arrowstyle=ArrowStyle.BarAB(widthA = 0.2, widthB = 0.2),
                                fc="k", ec="k"), **args)
    ax.annotate("", xytext=(xpos-v2x,ypos-v2y), xy=(xpos+v2x, ypos+v2y), 
                                 arrowprops=dict(arrowstyle=ArrowStyle.BarAB(widthA = 0.2, widthB = 0.2),
                                fc="k", ec="k"), **args)

plot_xy_erbars_angle_ax = lambda coords, deltas, ax1, thermal_sfac=1.0, **args: [draw_angle_errorbars(coords[i,0], coords[i,1],deltas[i,0],deltas[i,3],deltas[i,1],ax1,thermal_sfac,**args) for i in range(24)]

def save_figs_and_NSD_v2(filepath, imagepath1):
	nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, ref_str_mat)
	proper_assignment = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
	15, 16, 17, 18, 19, 20, 21, 22, 23]
	if ass_mat != proper_assignment:
		sad_ref = np.hstack((ref_str_mat[:,0:2], -1.76 * nb_b2u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, sad_ref)
	if ass_mat != proper_assignment:
		sad_ref_2 = np.hstack((ref_str_mat[:,0:2], 4 * nb_b2u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, sad_ref_2)
	if ass_mat != proper_assignment:
		dom_ref = np.hstack((ref_str_mat[:,0:2], 2 * nb_a2u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, dom_ref)
	#stuff to get 867177.pdb CCDC Dep No. to work. can't figure out why it isnt - worked okay in the other instance 
	if ass_mat != proper_assignment:
		mst_ref = np.hstack((ref_str_mat[:,0:2] + (0.38 * np.array(nb_b2g[0]).reshape(24,2)), 0.16 * nb_b2u[:,0] +  0.25 * nb_b1u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, mst_ref)
	if ass_mat != proper_assignment:
		mst_ref_2 = np.hstack((ref_str_mat[:,0:2] + (-0.38 * np.array(nb_b2g[0]).reshape(24,2)), 0.16 * nb_b2u[:,0] +  0.25 * nb_b1u[:,0]))
		nsd_mat, coords, ass_mat, deltas = nsd_fit_out_v4(filepath, mst_ref_2)
	
	fig, (ax1, ax2) = plt.subplots(1,2, figsize=(10.5,5))
	plot_xy_wlines_ax(ref_str_mat, ax1, marker = 'o',linestyle = 'dotted', color = 'red')
	plot_xy_wlines_ax(coords, ax1, marker = 'o',color = 'black')
	thermal_sfac = 0.5
	plot_xy_erbars_angle_ax(coords, deltas, ax1, thermal_sfac)

	ax1.plot(coords[20:,0],coords[20:,1], linestyle = 'none', marker = 'o',color = 'blue')
	ax1.set_title('In-plane distortion')
	ax1.set_xlabel(r'x position ($\AA$)')
	ax1.set_ylabel(r'y position ($\AA$)')
	
	ax2.plot([-180,180],[0,0], linestyle = 'dotted', color = 'red')
	skel_dev_plot_2_ax(coords, ax2, marker = 'o', color = 'black')
	skel_dev_plot_2_ax_erbars(coords, deltas, ax2, thermal_sfac, color = 'black')
	skel_dev_plot_2N_ax(coords, ax2, marker = 'o', color = 'blue')
	maxz = np.max(np.abs(coords[:,2]))
	ax2.set_xlim(-190,190)
	ax2.set_xticks([-180,-90,0,90,180])
	if maxz <1 :
		ax2.set_ylim(-1,1)
		ax2.set_yticks([-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1])
	else: ax2.set_ylim(-maxz-0.5,maxz+0.5)
	ax2.set_title('Out-of-plane distortion')
	ax2.set_xlabel(r'Angle in Cylindical coordinates ($\degree$)')
	ax2.set_ylabel(r'z position ($\AA$)')
	ax2.yaxis.set_label_position("right")
	ax2.yaxis.tick_right()
	plt.subplots_adjust(left = 0.07, right = 0.93, wspace = 0.1, top = 0.95)
	fig.savefig(imagepath1, dpi = 300)
	plt.clf()
	return (nsd_mat, coords, deltas)

# this is the subroutine for looking up an NSD profile from the full database
#which is generated by Gen_NSD_db. expected that this'll be the same for a PDB
#lookup, whenever I get around to that.

def save_figs_and_NSD_from_CCDC(NAME, imagepath1):
	nsd_comp_path = getcwd() + '/data/nsd_merged_20200420.pkl'
	nsd_df_comp = pd.read_pickle(nsd_comp_path)
	dfline = nsd_df_comp[nsd_df_comp['NAME']==NAME]
	nsd_mat, coords = dfline['NSD_matrix'].values[0], np.array(dfline['coords_matrix'].values[0])
	gen_nsd_fig(coords, imagepath1)
	return (nsd_mat, coords)

# from here, it's replicas of Save_NSD_from etc. with things filtered out to 
# account for atoms having correct names. (Correct_numbering subroutine)
#includes redefinitions of several of the functions, to import only those atoms,
#and removes the requirement of reordering the atoms.
#could potentially get stuck in a false minimum, but haven't observed it yet.

def import_pdb_correct_numbering(filelist, magic_n_radius = 3):
	co_list  = np.zeros((24,3))
	proper_names = ['C1' ,'C2' ,'C3' ,'C4' ,'C5' ,'C6' ,'C7' ,'C8' ,'C9' ,'C10','C11','C12','C13','C14','C15','C16','C17','C18','C19','C20','N21','N22','N23','N24']
	for index, l in enumerate(filelist): #l is line
		if len(l)>55 and l.split()[-1] in ['C','N'] and l.startswith(('HETATM','ATOM')):
			atname,x,y,z = l[12:16].strip(' '),l[31:39],l[39:47],l[47:55]
			if atname in proper_names:
				print(atname)
				co_list[proper_names.index(atname),:] = [float(v) for v in [x,y,z]]
	return np.array(co_list) #shouldn't need reordering

import_pdb_correct_numbering_f   = lambda filenm : import_pdb_correct_numbering(open(filenm,'r').readlines())
mat_dist_correct_numbering = lambda m1,m2: np.sum(np.square(m2-m1))
rotfunc_correct_numbering	  = lambda params, mats: mat_dist_correct_numbering(rt_atoms(params, mats[0]),mats[1])

def fit_atoms_correct_numbering(xyzmat, refmat = ref_str_mat, cycles = 1):
	porpfit = [0,0,0,0.1,0,0,0]
	for i in range(cycles):
		porpfit = minimize(rotfunc_correct_numbering, porpfit, [refmat, xyzmat]).x
	return inv_rt_atoms(porpfit, xyzmat)

def nsd_fit_out_correct_numbering(filenm, reference_matrix = ref_str_mat):
	raw_atoms = import_pdb_correct_numbering_f(filenm)
	nor_atoms = normalise_atoms(raw_atoms)
	xyz_final = fit_atoms_correct_numbering(nor_atoms, reference_matrix,1)
	nsd	   = gen_nsd_from_atoms_w_tot(xyz_final, trim_list)
	return nsd, xyz_final

def save_figs_and_NSD_correct_numbering(filepath, imagepath1):
	nsd_mat, coords = nsd_fit_out_correct_numbering(filepath, ref_str_mat)
	gen_nsd_fig(coords, imagepath1)
	return (nsd_mat, coords)
